---
/**
 * @component SmartImage
 * @description A highly reusable, responsive image component for Astro projects, built
 * on top of `astro:assets`. It simplifies generating multiple image formats (AVIF, WebP)
 * and sizes, while providing sensible defaults and advanced features like a CSS-driven
 * vignette effect.
 *
 * @feature Automatic responsive widths and `sizes` attribute generation for local images.
 * @feature Supports modern formats (`avif`, `webp`) with graceful fallbacks.
 * @feature Handles both local `ImageMetadata` objects and remote image URLs (string).
 * @feature Optional, configurable vignette overlay.
 * @feature Correctly handles CSS `border-radius` when a vignette is applied.
 * @feature Sensible defaults for quality, formats, and loading behavior.
 *
 * @see https://docs.astro.build/en/guides/assets/ for `ImageMetadata` and `<Picture>` behavior.
 *
 * @example
 * <!-- Basic usage with a local import -->
 * import localImage from '../assets/hero.png';
 * <SmartImage src={localImage} alt="A descriptive alt text." />
 *
 * @example
 * <!-- Usage with a remote image URL -->
 * <SmartImage src="https://example.com/image.jpg" alt="Remote image." />
 *
 * @example
 * <!-- With a vignette effect and rounded corners -->
 * <SmartImage
 *   src={localImage}
 *   alt="Image with a vignette."
 *   class="rounded-lg"
 *   vignetteRadius={60}
 *   vignetteStrength={0.4}
 * />
 */

import type { ImageMetadata } from "astro";
import { Picture } from "astro:assets";
import { DEFAULT_IMAGE_FORMATS, DEFAULT_IMAGE_QUALITY, DEFAULT_RESPONSIVE_WIDTHS } from "../constants";
import { extractRoundedClasses, generateOptimalWidths, generateSizes, removeRoundedClasses } from "../utils/images";

export interface Props {
  /**
   * The image source. This can be either an imported image asset (`ImageMetadata`)
   * from your project's `src/` directory, or a URL string pointing to a remote image.
   * When using a local import, `astro:assets` will optimize the image.
   * When using a string, a standard `<img>` tag is rendered without optimization.
   */
  src: ImageMetadata | string;

  /**
   * The `alt` text for the image. This is crucial for accessibility and SEO.
   * For purely decorative images, provide an empty string (`alt=""`).
   */
  alt: string;

  /**
   * The `sizes` attribute for the image, which helps the browser choose the best
   * image from the `srcset` based on the current layout.
   * If not provided, a default `sizes` attribute is generated based on the `widths`.
   * @default "(min-width: 1024px) 100vw, 100vw" or generated from widths.
   * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img#attr-sizes
   */
  sizes?: string;

  /**
   * An array of widths (in pixels) to generate for the responsive image.
   * If `src` is a local image and `widths` is not provided, a set of optimal
   * widths will be generated based on the image's original dimensions.
   * @default [640, 750, 828, 1080, 1200, 1920, 2560] (or derived from image)
   */
  widths?: number[];

  /**
   * An array of image formats to generate. Astro's `<Picture>` component will
   * create a `<source>` element for each format, ordered by preference.
   * @default ['avif', 'webp']
   */
  formats?: Array<"avif" | "webp" | "png" | "jpg">;

  /**
   * The quality setting (1-100) for the generated images.
   * @default 80
   */
  quality?: number;

  /**
   * A string of CSS classes to be applied to the root element.
   * Note: If a vignette is active, `rounded-*` classes are intelligently moved
   * to a wrapping container to ensure correct clipping of the effect.
   */
  class?: string;

  /**
   * Optional inline styles to apply to the underlying `<img>` / `<picture>` element.
   * This is accepted so parent components can pass `style` through via `...props`.
   */
  style?: string;

  /**
   * The loading strategy for the image.
   * - `lazy`: Defer loading until the image is about to enter the viewport. (Default)
   * - `eager`: Load the image immediately. Use for critical, above-the-fold images.
   * @default 'lazy'
   */
  loading?: "lazy" | "eager";

  /**
   * The radius of the vignette's transparent center, as a percentage (0-100).
   * For the vignette to be applied, both `vignetteRadius` and `vignetteStrength`
   * must be provided.
   * @example 70
   */
  vignetteRadius?: number;

  /**
   * The opacity of the vignette's dark outer edge, from 0 (transparent) to 1 (opaque).
   * For the vignette to be applied, both `vignetteRadius` and `vignetteStrength`
   * must be provided.
   * @example 0.5
   */
  vignetteStrength?: number;

  /**
   * Visual resize strategy for the rendered image. Maps to CSS `object-fit`.
   * @default 'cover'
   */
  fit?: "cover" | "contain" | "fill" | "none" | "scale-down";

  /**
   * Crop anchor for the image. Maps to CSS `object-position` (e.g. "center", "top", "50% 30%").
   * @default 'center'
   */
  position?: string;

  /**
   * Optional credit label rendered as an overlay on the image.
   * Provide plain text (HTML is not rendered).
   * Example: "Photo © MjøsDrone"
   */
  credit?: string;

  /**
   * Where to place the credit overlay.
   * @default 'bottom-right'
   */
  creditAnchor?: "top-left" | "top-right" | "bottom-right" | "bottom-left";

  /**
   * Override classes for the credit chip. If omitted, a sensible default is used.
   * Provide Tailwind or plain CSS classes.
   */
  creditClass?: string;

  /**
   * Optional inline styles for the credit chip (applied to the chip wrapper).
   */
  creditStyle?: string;
}

const {
  src,
  alt,
  sizes,
  widths,
  formats = DEFAULT_IMAGE_FORMATS as Props["formats"],
  quality = DEFAULT_IMAGE_QUALITY,
  class: className,
  loading = "lazy",
  vignetteRadius,
  vignetteStrength,

  // Explicitly capture inline style so we can decide where to apply it.
  // When a vignette is active, the overlay is sized to the WRAPPER (absolute inset:0),
  // so the wrapper must receive the sizing styles (width/height/object-fit) to match
  // the visible pixels of the media. The inner media then fills the wrapper.
  style: inlineStyle,
  fit = "cover",
  position = "center",

  // Pass-through for all other attributes (e.g. data-*).
  ...props
} = Astro.props;

/**
 * Type guard to check if the `src` prop is a local `ImageMetadata` object.
 * This is how we differentiate between optimizable local assets and remote URLs.
 * @param s The `src` prop.
 * @returns `true` if `src` is an `ImageMetadata` object.
 */
const isImageMetadata = (s: Props["src"]): s is ImageMetadata => {
  // `ImageMetadata` objects have `width` and `height` properties.
  return typeof s === "object" && "width" in s && "height" in s;
};

// When `src` is a local image, we can generate intelligent defaults for `widths` and `sizes`.
// If `src` is a remote string, we fall back to a standard set of widths.
const defaultWidths = isImageMetadata(src) ? generateOptimalWidths(src.width) : DEFAULT_RESPONSIVE_WIDTHS;

// Similarly, generate a `sizes` attribute if one isn't provided.
const defaultSizes = isImageMetadata(src) ? generateSizes(defaultWidths) : "(min-width: 1024px) 100vw, 100vw";

// Use the user-provided prop if it exists, otherwise fall back to our generated default.
const finalWidths = widths ?? defaultWidths;
const finalSizes = sizes ?? defaultSizes;

// Move rounded-* classes to a wrapper when vignette is active so the overlay clips correctly.
const roundedClasses = extractRoundedClasses(className);
const innerImageClasses = removeRoundedClasses(className);

/**
 * Compute wrapper vs inner styles:
 *  - With vignette: wrapper gets the caller’s inlineStyle (so the overlay’s box matches),
 *    and the inner media is forced to fill that box while inheriting object-fit.
 *  - Without vignette: keep original behavior and apply inlineStyle directly to the media.
 */
const vignetteActive = vignetteRadius !== undefined && vignetteStrength !== undefined;

/** Build styles ensuring object-fit works (requires width & height). */
const fitStyle = `object-fit: ${fit};`;
const positionStyle = `object-position: ${position};`;

// Credit overlay inputs and overlay flag.
const creditText = (Astro.props as Props).credit?.trim();
const creditAnchor = (Astro.props as Props).creditAnchor ?? "bottom-right";
const creditClassOverride = (Astro.props as Props).creditClass;
const creditStyle = (Astro.props as Props).creditStyle;
const creditActive = !!creditText;
const overlayActive = vignetteActive || creditActive;

// Wrapper classes must carry sizing. Keep rounded on wrapper, and also carry the original `class`.
const wrapperClasses = [roundedClasses, className].filter(Boolean).join(" ").trim();

// When any overlay is active, the wrapper becomes the positioning context for vignette/credit.
// Give it position:relative, preserve caller inline styles, and clip if needed.
// For local images, also offer an aspect-ratio fallback so the wrapper has a natural height
// when authors did not specify explicit sizes.
const aspectRatioFallback = overlayActive && isImageMetadata(src) ? `aspect-ratio: ${src.width}/${src.height};` : "";

// IMPORTANT: We must also clip when ONLY a credit is present (no vignette, no rounded classes),
// otherwise the absolutely-positioned chip may render outside of the image box in some layouts.
// This ensures credit overlays are always constrained to the media bounds.
const needsOverflowClip = vignetteActive || !!roundedClasses || creditActive;

const wrapperStyle = overlayActive
  ? [
      inlineStyle, // caller sizing goes to the wrapper
      "position: relative;", // credit positions against this
      needsOverflowClip ? "overflow: hidden;" : undefined,
      aspectRatioFallback, // harmless when explicit height is provided
    ]
      .filter(Boolean)
      .join(" ")
  : undefined;

const innerStyle = overlayActive
  ? // With an overlay, make the media fill the wrapper so object-fit/position apply to the visible box.
    ["width: 100%; height: 100%;", fitStyle, positionStyle].filter(Boolean).join(" ")
  : [inlineStyle, fitStyle, positionStyle].filter(Boolean).join(" ");

/** Framework-agnostic default chip style and anchor mapping. */
const defaultCreditStyle = [
  "pointer-events: none",
  "position: absolute",
  "z-index: 20",
  "margin: 8px",
  // Subtle text-only treatment: no chip background or borders
  "font-size: 11px",
  "line-height: 1.25",
  "font-weight: 400",
  "color: rgba(255,255,255,0.85)",
  // Gentle contrast helper on busy imagery without a box
  "text-shadow: 0 1px 2px rgba(0,0,0,0.45), 0 0 1px rgba(0,0,0,0.6)",
  "user-select: none",
].join("; ");

function anchorToStyle(a: NonNullable<Props["creditAnchor"]>): string {
  if (a === "top-left") return "top: 8px; left: 8px;";
  if (a === "top-right") return "top: 8px; right: 8px;";
  if (a === "bottom-left") return "bottom: 8px; left: 8px;";
  return "bottom: 8px; right: 8px;";
}
---

{
  /**
   * Main render logic.
   * We have two primary branches: one for when an overlay (vignette or credit) is applied,
   * and one for when it's not.
   *
   * When an overlay is present, we wrap the media in a positioned container that also clips
   * rounded corners. With vignette active, the wrapper receives inline sizing and object-fit
   * so that the gradient conforms to the visible box. With credit-only, we keep sizing on the
   * inner media and just provide a positioned overlay host.
   */
}
{
  // Branch 1: Any overlay is active (vignette OR credit).
  overlayActive ? (
    <div class={wrapperClasses} style={wrapperStyle}>
      {/* Render the core image element (`<Picture>` or `<img>`) */}
      {isImageMetadata(src) ? (
        <Picture
          src={src}
          alt={alt}
          sizes={finalSizes}
          widths={finalWidths}
          formats={formats}
          quality={quality}
          loading={loading}
          class={innerImageClasses}
          style={innerStyle}
          {...props}
        />
      ) : (
        // For remote images, `astro:assets` cannot be used. We fall back to a
        // standard `<img>` tag as per Astro's official guidance.
        <img src={src as string} alt={alt} loading={loading} class={innerImageClasses} style={innerStyle} {...props} />
      )}

      {/* 
        The vignette overlay element sized to the wrapper (absolute inset:0).
        Because the wrapper now owns the sizing, the radial gradient conforms
        to the same visible region as the image (no mismatch when object-fit crops).
      */}
      {vignetteActive && (
        <div
          style={`
            position: absolute;
            inset: 0;
            pointer-events: none;
          /* Fallback for very old browsers that don't support radial gradients. */
            background: transparent;
          
          /* Prefixed version for older Safari/Chrome. */
            background: -webkit-radial-gradient(ellipse at center, transparent ${vignetteRadius}%, rgba(0,0,0,${vignetteStrength}) 100%);
          
          /* Standard CSS syntax. */
            background: radial-gradient(ellipse at center, transparent ${vignetteRadius}%, rgba(0,0,0,${vignetteStrength}) 100%);
          `}
        />
      )}

      {/* Credit overlay (if provided) */}
      {creditActive && (
        <div
          class={creditClassOverride}
          style={[defaultCreditStyle, anchorToStyle(creditAnchor), creditStyle].filter(Boolean).join("; ")}
          aria-hidden="true"
        >
          {creditText}
        </div>
      )}
    </div>
  ) : // Branch 2: No overlays at all (render media directly)
  isImageMetadata(src) ? (
    // Render the `<Picture>` component directly.
    <Picture
      src={src}
      alt={alt}
      sizes={finalSizes}
      widths={finalWidths}
      formats={formats}
      quality={quality}
      loading={loading}
      class={className}
      style={innerStyle}
      {...props}
    />
  ) : (
    // Render the standard `<img>` tag directly for remote images.
    <img src={src as string} alt={alt} loading={loading} class={className} style={innerStyle} {...props} />
  )
}
