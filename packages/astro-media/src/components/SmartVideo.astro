---
/**
 * @component SmartVideo
 * @description A flexible component for rendering fullscreen or container-bound background videos.
 * It handles the complexities of modern video playback, including HLS streaming with automatic
 * fallbacks to standard MP4/WebM, and robust autoplay logic that respects browser policies.
 *
 * @feature Supports HLS streaming via `hls.js` for adaptive bitrate streaming.
 * @feature Gracefully falls back to standard `<video>` sources (`.mp4`/`.webm`) if HLS is
 *   unsupported or not provided.
 * @feature Uses native HLS playback on Safari for optimal performance.
 * @feature Intelligent autoplay: uses IntersectionObserver to play/pause when in view.
 * @feature Optional play-on-hover functionality.
 * @feature Includes a poster image (`<SmartImage>`) for fast initial paint and as a
 *   fallback visual.
 * @feature Injects SEO-friendly JSON-LD `VideoObject` schema if metadata is provided.
 *
 * @see https://github.com/video-dev/hls.js/ for HLS client-side library.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
 *
 * @example
 * <!-- With HLS and a fallback -->
 * <SmartVideo
 *   hlsSrc="/videos/stream/index.m3u8"
 *   src="/videos/fallback/drone"
 *   poster={posterImage}
 *   class="h-[60vh]"
 * />
 *
 * @example
 * <!-- Play on hover only -->
 * <SmartVideo
 *   src="/videos/drone"
 *   poster={posterImage}
 *   playOnHover={true}
 * />
 */

import type { ImageMetadata } from "astro";
import { DEFAULT_DURATION_ISO } from "../constants";
import SmartImage from "./SmartImage.astro";

/**
 * Defines the structured metadata for the video, used for generating
 * a JSON-LD `VideoObject` schema for SEO purposes.
 */
interface MetadataProps {
  /** A descriptive title for the video. */
  title?: string;
  /** A brief summary of the video's content. */
  description?: string;
  /** The duration of the video in ISO 8601 format (e.g., "PT1M30S"). */
  duration?: string;
  /** The original upload date of the video. */
  uploadDate?: Date;
  /** A URL to a thumbnail image. Defaults to the poster image if not provided. */
  thumbnailUrl?: string;
}

export interface Props {
  /**
   * The base path for the fallback video files (without extension). The component
   * will automatically append `.webm` and `.mp4` to create `<source>` elements.
   * This is used if `hlsSrc` is not provided, or if HLS playback fails.
   * @example "/videos/hero-fallback"
   */
  src?: string;

  /**
   * The URL to the HLS manifest file (`.m3u8`). If provided, the component will
   * attempt to use `hls.js` for adaptive streaming.
   */
  hlsSrc?: string;

  /**
   * The poster image to display before the video loads. This can be a local
   * `ImageMetadata` import or a remote URL string.
   */
  poster?: string | ImageMetadata;

  /** A string of CSS classes to be applied to the root container `div`. */
  class?: string;

  /**
   * Whether the video should attempt to play automatically.
   * This is ignored if `playOnHover` is `true`.
   * @default true
   */
  autoplay?: boolean;

  /**
   * Whether the video should loop continuously.
   * @default true
   */
  loop?: boolean;

  /**
   * Whether the video should be muted. Autoplay in most modern browsers
   * is only allowed for muted videos.
   * @default true
   */
  muted?: boolean;

  /**
   * Whether to display the browser's default video controls.
   * @default false
   */
  controls?: boolean;

  /**
   * The `playsinline` attribute, which is critical for preventing fullscreen
   * playback on iOS devices.
   * @default true
   */
  playsinline?: boolean;

  /**
   * How aggressively to preload the video resource.
   * Defaults to `"metadata"` to limit bandwidth while keeping first-frame fast.
   * @default "metadata"
   */
  preload?: "none" | "metadata" | "auto";

  /**
   * If `true`, the video will only play when the user hovers the mouse over it.
   * The poster image is shown when the video is paused.
   * @default false
   */
  playOnHover?: boolean;

  /**
   * When set to "on-error", the poster will NOT be rendered initially and will only
   * be injected into the DOM if the video fails to load (native error or after HLS
   * fallback also errors). Default "eager" preserves existing behavior.
   * @default "eager"
   */
  posterLoadStrategy?: "eager" | "on-error";

  /**
   * Rich metadata for SEO (schema.org `VideoObject`). If provided, a
   * `<script type="application/ld+json">` tag will be injected.
   */
  metadata?: MetadataProps;

  // --- Poster <SmartImage> Props ---

  /** Vignette radius to pass to the internal `<SmartImage>` poster (0–100). */
  imgVignetteRadius?: number;
  /** Vignette strength to pass to the internal `<SmartImage>` poster (0–1). */
  imgVignetteStrength?: number;
  /** `sizes` attribute for the poster image. */
  imgSizes?: string;
  /** `widths` attribute for the poster image. */
  imgWidths?: number[];
  /** `formats` attribute for the poster image. */
  imgFormats?: Array<"avif" | "webp" | "png" | "jpg">;
  /** `quality` attribute for the poster image. */
  imgQuality?: number;

  /**
   * Visual resize strategy for both the poster and the <video>.
   * Maps to CSS `object-fit`.
   * @default 'cover' (or 'contain' when sizeStrategy === 'intrinsic')
   */
  fit?: "cover" | "contain" | "fill" | "none" | "scale-down";

  /**
   * Crop anchor for poster/video. Maps to CSS `object-position` (e.g. "center", "top",
   * "50% 30%", "left bottom").
   * @default 'center'
   */
  objectPosition?: string;

  /**
   * Framework-agnostic sizing behavior for the root container.
   * - "fill": always set `width: 100%` and `height: 100%` inline on the root.
   * - "none": do not set inline width/height; sizing is left entirely to the caller’s CSS.
   * - "intrinsic": let the `<video>` be in normal flow (`width:100%; height:auto`) so height is
   *   computed from its intrinsic aspect ratio. The poster matches this behavior. Useful when
   *   you do not know the media dimensions ahead of time and want automatic height.
   * @default "fill"
   */
  sizeStrategy?: "fill" | "none" | "intrinsic";

  /**
   * Optional HTML5 text tracks to attach to the <video>. Used for time-aligned metadata
   * (e.g., chapter/segment keys).
   */
  tracks?: Array<{
    kind: "metadata" | "chapters" | "subtitles" | "captions" | "descriptions";
    src: string;
    label?: string;
    srclang?: string;
    default?: boolean;
  }>;
}

// #region Extract and Process Props
// ---

const {
  src,
  hlsSrc,
  poster,
  class: className = "",
  autoplay = true,
  loop = true,
  muted = true,
  controls = false,
  playsinline = true,
  playOnHover = false,
  preload = "metadata",
  metadata,
  imgVignetteRadius,
  imgVignetteStrength,
  imgSizes,
  imgWidths,
  imgFormats,
  imgQuality,
  fit = "cover",
  objectPosition = "center",
  sizeStrategy = "fill",
  tracks = [],
  posterLoadStrategy = "eager",
} = Astro.props;

// ---
// #endregion

// #region Helper Functions
// ---

/**
 * A helper function to extract the `src` string from either a URL string
 * or an `ImageMetadata` object.
 * @param source The poster prop.
 * @returns The string URL of the image source.
 */
function getSourceString(source: string | ImageMetadata): string {
  return typeof source === "string" ? source : source.src;
}

const posterSrc = poster ? getSourceString(poster) : undefined;
const posterMode = posterLoadStrategy === "on-error" ? "on-error" : "eager";

/** Resolve effective visual strategy defaults. */
const effectiveFit = (fit ?? "cover") as "cover" | "contain" | "fill" | "none" | "scale-down";
const effectiveObjectPosition = objectPosition ?? "center";

/**
 * Compute inline style for the root container:
 * - Always cap width via max-width for safety.
 * - Inline width/height are controlled explicitly by `sizeStrategy`,
 *   making this behavior framework-agnostic and predictable.
 */
const rootStyle = [
  "position: relative;", // Ensure absolute children are anchored even without Tailwind.
  "overflow: hidden;", // Clip poster/video without relying on Tailwind.
  "max-width: 100%;",
  sizeStrategy === "fill" ? "width: 100%;" : "",
  sizeStrategy === "fill" ? "height: 100%;" : "",
]
  .filter(Boolean)
  .join(" ");

/**
 * Inline styles for the `<video>` based on sizing strategy.
 * - intrinsic: use the element's intrinsic aspect ratio to compute height.
 * - others: keep absolute cover behavior for background-style usage.
 */
const videoStyle =
  sizeStrategy === "intrinsic"
    ? `display: block; position: static; width: 100%; height: auto; object-fit: ${effectiveFit}; object-position: ${effectiveObjectPosition}; z-index: 1;`
    : `position: absolute; inset: 0; width: 100%; height: 100%; object-fit: ${effectiveFit}; object-position: ${effectiveObjectPosition}; z-index: 1;`;

/** Poster mirrors the same visual behavior. */
const posterObjectFit = effectiveFit;

// ---
// #endregion

// #region SEO JSON-LD Schema
// ---

/**
 * Construct the `VideoObject` for JSON-LD if metadata is provided.
 * This helps search engines understand the content of the video.
 */
const videoMetadata = metadata && {
  "@context": "https://schema.org",
  "@type": "VideoObject",
  name: metadata.title || "Background Video",
  description: metadata.description || "Background video content",
  thumbnailUrl: metadata.thumbnailUrl || posterSrc,
  uploadDate: metadata.uploadDate ? metadata.uploadDate.toISOString() : new Date().toISOString(),
  duration: metadata.duration || DEFAULT_DURATION_ISO,
};

// ---
// #endregion
---

<!--
  The root container passes all necessary configuration to the client-side script
  via `data-*` attributes. This is a standard Astro pattern for hydrating components
  with dynamic data without needing `define:vars`.
-->
<div
  data-component="smart-video"
  data-hls-src={hlsSrc ?? ""}
  data-src-fallback={src ?? ""}
  data-autoplay={autoplay ? "true" : "false"}
  data-play-on-hover={playOnHover ? "true" : "false"}
  class={`${className}`}
  style={rootStyle}
  data-poster-mode={poster ? posterMode : undefined}
>
  <!-- Inject the JSON-LD schema if it was created. -->
  {videoMetadata && <script type="application/ld+json" set:html={JSON.stringify(videoMetadata)} />}

  <!-- 
    The poster element. It uses <SmartImage> for performance. It's positioned
    absolutely to cover the video element until playback begins.
  -->
  {
    poster && posterMode === "eager" && (
      <div
        data-poster
        style="
          position: absolute;
          inset: 0;
          z-index: 2; /* Ensure poster paints above <video> */
          pointer-events: none; /* Overlay never blocks hover/clicks on container */
          transition: opacity 150ms ease-out;
          overflow: hidden; /* Clip to container so cropping matches SmartImage behavior */
        "
      >
        <SmartImage
          src={poster}
          alt={metadata?.title || "Video poster"}
          loading="eager"
          sizes={imgSizes}
          widths={imgWidths}
          formats={imgFormats}
          quality={imgQuality}
          vignetteRadius={imgVignetteRadius}
          vignetteStrength={imgVignetteStrength}
          fit={posterObjectFit}
          position={effectiveObjectPosition}
          style="width: 100%; height: 100%;"
        />
      </div>
    )
  }

  {
    poster && posterMode === "on-error" && (
      <>
        <div
          data-poster
          style="
            position: absolute;
            inset: 0;
            z-index: 2;
            pointer-events: none;
            transition: opacity 150ms ease-out;
            overflow: hidden;
          "
        ></div>

        <!-- Inert poster markup: no network until injected on error -->
        <template data-poster-template>
          <SmartImage
            src={poster}
            alt={metadata?.title || "Video poster"}
            loading="eager"
            sizes={imgSizes}
            widths={imgWidths}
            formats={imgFormats}
            quality={imgQuality}
            vignetteRadius={imgVignetteRadius}
            vignetteStrength={imgVignetteStrength}
            fit={posterObjectFit}
            position={effectiveObjectPosition}
            style="width: 100%; height: 100%;"
          />
        </template>
      </>
    )
  }

  <!-- 
    The core HTML5 <video> element. It starts empty and is populated with <source>
    elements by the client-side script.
  -->
  <video
    data-video
    preload={preload}
    loop={loop ? true : undefined}
    muted={muted ? true : undefined}
    controls={controls ? true : undefined}
    playsinline={playsinline ? true : undefined}
    webkit-playsinline={playsinline ? true : undefined}
    crossorigin="anonymous"
    style={videoStyle}
  >
    {
      Array.isArray(tracks) &&
        tracks.map((trk) => (
          <track
            kind={trk.kind}
            src={trk.src}
            label={trk.label}
            srclang={trk.srclang}
            default={trk.default ? true : undefined}
          />
        ))
    }
    <!-- Fallback message for browsers that don't support the <video> tag. -->
    <p>Your browser doesn't support HTML5 video.</p>
  </video>
</div>

<!-- 
  Client-Side Logic:
  This script is processed by Astro as a module. It will only be included once per page,
  even if multiple <SmartVideo> components are present. It queries for all component
  instances and initializes them based on their unique `data-*` attributes.
-->
<script>
  // Import the HLS.js library for adaptive streaming.
  import type Hls from "hls.js";

  /**
   * Manages the state and interactions of a single SmartVideo component instance.
   * This class encapsulates all client-side logic, including HLS playback,
   * fallbacks, and IntersectionObserver-based autoplay.
   */
  class SmartVideoPlayer {
    private _container: HTMLElement;
    private _videoElement: HTMLVideoElement;
    private _posterElement: HTMLElement | null;
    private _hlsInstance: Hls | null = null;
    private _observer: IntersectionObserver | null = null;

    // HLS readiness and retry bookkeeping (hls.js path only).
    private _hlsReady: boolean = false;                  // Set true on MANIFEST_PARSED
    private _hlsStartupTimer: number | null = null;      // Watchdog to avoid hanging on startup
    private _hlsNetworkErrorCount: number = 0;           // Bounded retries for fatal NETWORK errors

    // Configuration flags read from data attributes
    private _hlsSrc: string | null;
    private _fallbackSrc: string | null;
    private _playOnHover: boolean;
    private _shouldAutoplay: boolean;
    private _hlsFailed = false;

    // Poster lazy-injection state
    private _posterMode: "eager" | "on-error";
    private _posterTemplate: HTMLTemplateElement | null;
    private _posterInjected = false;

    // Hover bookkeeping:
    //  - _hoverTarget is the element that owns hover intent (wrapper if present, otherwise the component container).
    //  - _isHovering reflects whether the pointer is currently over _hoverTarget.
    private _hoverTarget: HTMLElement | null = null;
    private _isHovering: boolean = false;

    /**
     * Initializes the player instance.
     * @param {HTMLElement} container - The root `div` element of the component.
     */
    constructor(container: HTMLElement) {
      this._container = container;
      const videoEl = container.querySelector<HTMLVideoElement>("[data-video]");
      const posterEl = container.querySelector<HTMLElement>("[data-poster]");

      if (!videoEl) {
        throw new Error("SmartVideoPlayer: A [data-video] element is required.");
      }

      this._videoElement = videoEl;
      this._posterElement = posterEl;

      // Read configuration from the container's data attributes.
      this._hlsSrc = container.dataset.hlsSrc || null;
      this._fallbackSrc = container.dataset.srcFallback || null;
      this._playOnHover = container.dataset.playOnHover === "true";
      this._shouldAutoplay = !this._playOnHover && container.dataset.autoplay === "true";
      this._posterMode = (container.dataset.posterMode as "eager" | "on-error") || "eager";
      this._posterTemplate = container.querySelector<HTMLTemplateElement>("[data-poster-template]");

      if (this._shouldAutoplay) {
        this._videoElement.setAttribute("autoplay", "");
      }

      // Mark initial visibility synchronously to avoid waiting for IO callback
      const r = this._container.getBoundingClientRect();

      if (r.top < window.innerHeight && r.bottom > 0 && r.left < window.innerWidth && r.right > 0) {
        this._container.setAttribute("data-is-intersecting", "true");
      }

      // Resolve the element users actually hover: prefer the wrapper parent when present.
      this._hoverTarget =
        this._container.parentElement instanceof HTMLElement ? this._container.parentElement : this._container;
    }

    /**
     * Sets up event listeners and initializes the appropriate video source
     * (HLS or standard fallback).
     */
    public async initialize(): Promise<void> {
      this._setupEventListeners();

      const hlsInitialized = await this._initializeHLS();
      if (!hlsInitialized) {
        this._appendFallbackSources();
      }

      // Also attempt autoplay once the browser reports it can play.
      // This covers both HLS and non-HLS (fallback) paths.
      this._videoElement.addEventListener("canplay", () => this._maybeAutoplayOnReady(), { once: true });

      // Autoplay logic is only enabled if hover-to-play is not active.
      if (this._shouldAutoplay) {
        this._initializeObserver();
      }
    }

    /**
     * Attempt playback only when the media is ready. If we're in hover mode,
     * we additionally require that the pointer is still over the hover target
     * at the instant we decide to start playback.
     */
    private _playWhenReady(): void {
      // If this path was triggered by hover, ensure hover intent is still active.
      if (this._playOnHover && (!this._hoverTarget || !this._isHovering)) {
        return;
      }
  
      // HAVE_CURRENT_DATA (2) is sufficient to begin playback.
      if (this._videoElement.readyState >= 2) {
        if (!this._playOnHover || this._isHovering) {
          this._attemptPlay();
        }
        return;
      }
  
      const onReady = (): void => {
        this._videoElement.removeEventListener("canplay", onReady);
  
        // Guard again: if the user left before readiness, do nothing.
        if (this._playOnHover && (!this._hoverTarget || !this._isHovering)) {
          return;
        }
  
        this._attemptPlay();
      };

      this._videoElement.addEventListener("canplay", onReady, { once: true });
    }

    /**
     * Attempt autoplay if we're intersecting and autoplay is enabled.
     * Called from readiness signals (HLS MANIFEST_PARSED, media 'canplay').
     */
    private _maybeAutoplayOnReady(): void {
      if (!this._shouldAutoplay) {
        return;
      }

      const alreadyFlagged = this._container.getAttribute("data-is-intersecting") === "true";
      const rect = this._container.getBoundingClientRect();
      const visibleNow =
        rect.top < window.innerHeight && rect.bottom > 0 && rect.left < window.innerWidth && rect.right > 0;

      if (alreadyFlagged || visibleNow) {
        this._attemptPlay();
      }
    }

    /**
     * Attempts to play the video, handling potential browser errors for blocked autoplay.
     * It retries with the video muted if the initial attempt fails.
     */
    private _attemptPlay(): void {
      const playPromise = this._videoElement.play();
      if (playPromise) {
        playPromise.catch((err) => {
          console.info("SmartVideo: Autoplay was blocked. Muting and retrying.", err);
          this._videoElement.muted = true;
          this._videoElement.play().catch((err2) => {
            console.info("SmartVideo: Muted autoplay also failed.", err2);
          });
        });
      }
    }

    /**
     * Sets up all necessary DOM event listeners for the component.
     */
    private _setupEventListeners(): void {
      // Fade out the poster when the video starts playing.
      this._videoElement.addEventListener("playing", () => {
        if (this._posterElement) {
          this._posterElement.style.opacity = "0";
        }
      });

      // Show the poster again when paused if hover-to-play is enabled.
      this._videoElement.addEventListener("pause", () => {
        if (this._posterElement && this._playOnHover) {
          this._posterElement.style.opacity = "1";
        }
      });

      // If the video encounters an unrecoverable error (native path or after fallback),
      // inject the poster only when posterMode === "on-error".
      this._videoElement.addEventListener("error", () => {
        this._handleVideoError();
      });

      // Handle hover-based playback.
      if (this._playOnHover) {
        // Attach to the element users actually hover (wrapper if present).
        const target = this._hoverTarget ?? this._container;
  
        const onEnter = (): void => {
          this._isHovering = true;
          this._playWhenReady();
        };
  
        const onLeave = (): void => {
          this._isHovering = false;
          this._videoElement.pause();
        };
  
        target.addEventListener("mouseenter", onEnter);
        target.addEventListener("mouseleave", onLeave);
      }
    }

    /**
     * Injects the poster image from the inert template if configured to do so,
     * ensuring no network request occurred until this failure moment.
     */
    private _ensurePosterInjected(): void {
      if (this._posterInjected) {
        return;
      }

      if (!this._posterElement || !this._posterTemplate) {
        return;
      }

      const fragment = this._posterTemplate.content.cloneNode(true) as DocumentFragment;
      this._posterElement.appendChild(fragment);

      this._posterInjected = true;
      this._posterElement.style.opacity = "1";
    }

    /**
     * Handle native video errors by showing the poster when configured for on-error.
     */
    private _handleVideoError(): void {

      if (this._posterMode === "on-error") {
        this._ensurePosterInjected();
      }
    }

    /**
     * Appends standard `<source>` elements for WebM and MP4 formats.
     * This is used as a fallback if HLS is not supported or fails.
     */
    private _appendFallbackSources(): void {
      if (!this._fallbackSrc) return;

      // Clear any existing sources before adding new ones.
      this._videoElement.innerHTML = "";

      const sourceWebm = document.createElement("source");
      sourceWebm.src = `${this._fallbackSrc}.webm`;
      sourceWebm.type = "video/webm";
      this._videoElement.appendChild(sourceWebm);

      const sourceMp4 = document.createElement("source");
      sourceMp4.src = `${this._fallbackSrc}.mp4`;
      sourceMp4.type = "video/mp4";
      this._videoElement.appendChild(sourceMp4);

      // We need to tell the video element to load the new sources.
      this._videoElement.load();
    }

    /**
     * Shared helper to pivot from HLS to static <source> fallbacks.
     * Ensures we do this exactly once and then re-attempt playback if we should be playing.
     */
    private _fallbackFromHls(): void {
      // Mark that we should not attempt HLS again during this lifecycle.
      this._hlsFailed = true;

      // Stop any startup watchdog.
      if (this._hlsStartupTimer !== null) {
        clearTimeout(this._hlsStartupTimer);
        this._hlsStartupTimer = null;
      }

      // Tear down any active hls.js instance (no-op if null).
      this._hlsInstance?.destroy();

      // Surface playback path for diagnostics/inspection UIs.
      this._container.setAttribute("data-playback-mode", "fallback");

      // Clear any native src and switch to appended sources.
      this._videoElement.removeAttribute("src");
      this._appendFallbackSources();

      // If no MP4/WebM fallback was provided, ensure the poster is shown.
      if (!this._fallbackSrc) {
        console.warn("SmartVideo: No MP4/WebM fallback provided; showing poster due to HLS failure.");
        this._ensurePosterInjected();
        return;
      }

      // If we are visible and expected to autoplay, try to play now.
      if (this._container.getAttribute("data-is-intersecting") === "true" && this._videoElement.paused) {
        this._attemptPlay();
      }
    }

    /**
     * Initializes HLS playback if an HLS source is provided and the browser supports it.
     * Uses native HLS when available; otherwise dynamically imports hls.js.
     * @returns {Promise<boolean>} `true` if HLS was successfully initialized, `false` otherwise.
     */
    private async _initializeHLS(): Promise<boolean> {
      if (!this._hlsSrc) return false;

      // Safari on macOS and iOS has native HLS support.
      if (this._videoElement.canPlayType("application/vnd.apple.mpegurl")) {
        // Native path: set the src and guard with a watchdog so we don't hang forever in environments
        // where canPlayType() is overly optimistic or codecs are unavailable (e.g., CI WebKit builds).
        const v = this._videoElement;

        let settled = false; // tracks whether ready or error fired
        const settle = (): void => {
          if (settled) return;
          settled = true;
          v.removeEventListener("loadedmetadata", onReady);
          v.removeEventListener("canplay", onReady);
          v.removeEventListener("error", onError);
        };

        const onReady = (): void => {
          settle();
          // Expose that native HLS is active.
          this._container.setAttribute("data-playback-mode", "native-hls");
          // Defer to normal ready → maybe autoplay flow.
          this._maybeAutoplayOnReady();
        };

        const onError = (): void => {
          settle();
          console.warn("SmartVideo: Native HLS failed to become ready. Falling back to <source>.");

          if (this._posterMode === "on-error") {
            this._ensurePosterInjected();
          }

          this._fallbackFromHls();
        };

        v.addEventListener("loadedmetadata", onReady, { once: true });
        v.addEventListener("canplay", onReady, { once: true });
        v.addEventListener("error", onError, { once: true });

        // Assign after listeners in case the event fires immediately.
        v.src = this._hlsSrc;

        // Watchdog timeout as a last resort if neither ready nor error fires promptly.
        window.setTimeout(() => {
          if (!settled) onError();
        }, 4000);

        return true;
      }

      // Dynamically import hls.js only when needed to avoid blocking page load.
      let HlsMod: typeof Hls;

      try {
        HlsMod = await import("hls.js");
      } catch (e) {
        console.warn("SmartVideo: Failed to load hls.js module; using fallback sources.", e);
        return false;
      }

      const Hls = HlsMod?.default;

      // Use hls.js for other browsers that support Media Source Extensions.
      if (Hls && Hls.isSupported()) {
        // Conservative, startup-focused defaults. See hls.js config docs.
        this._hlsInstance = new Hls({
          startLevel: 0, // ensure smallest rendition first for fastest first frame
          startFragPrefetch: true, // fetch next frag while playing current
          autoStartLoad: true,
          capLevelToPlayerSize: true,
          lowBufferWatchdogPeriod: 0.5,
          highBufferWatchdogPeriod: 2,
          nudgeMaxRetry: 3,
        });

        this._hlsInstance.loadSource(this._hlsSrc);
        this._hlsInstance.attachMedia(this._videoElement);

        // Startup watchdog: if MANIFEST_PARSED never arrives, pivot to fallback/poster.
        this._hlsStartupTimer = window.setTimeout(() => {
          if (!this._hlsReady && !this._hlsFailed) {
            console.warn("SmartVideo: HLS startup timed out; switching to MP4/WebM fallback or poster.");
            this._fallbackFromHls();
          }
        }, 4000);

        // When the manifest is parsed, HLS is ready to start playback.
        // If we're intersecting and autoplay is desired, try again now.
        this._hlsInstance.on(Hls.Events.MANIFEST_PARSED, () => {
          this._container.setAttribute("data-playback-mode", "hls.js");
          this._hlsReady = true;

          if (this._hlsStartupTimer !== null) {
            clearTimeout(this._hlsStartupTimer);
            this._hlsStartupTimer = null;
          }
          this._maybeAutoplayOnReady();
        });

        this._hlsInstance.on(Hls.Events.ERROR, (event, data) => {
          const details = (data && (data as any).details) || "unknown";
          const fatal = !!(data && (data as any).fatal);

          // Downgrade noisy, non-fatal stall logs.
          if (!fatal) {
            if (details === "bufferStalledError" || details === "bufferNudgeOnStall") {
              console.debug("SmartVideo: non-fatal HLS stall:", details);
            } else {
              console.warn("SmartVideo: non-fatal HLS error:", details);
            }
            return;
          }

          // EARLY POSTER on first fatal error if requested, before any retry/pivot logic.
          if (this._posterMode === "on-error") {
            console.warn("SmartVideo: fatal HLS error; injecting poster.");
            this._ensurePosterInjected();

            // Also pivot off HLS so we don’t keep retrying behind the poster.
            this._fallbackFromHls();

            return;
          }

          // Attempt targeted recovery before falling back.
          try {
            const type = (data as any).type;
            if (type === Hls.ErrorTypes.NETWORK_ERROR) {
              // Allow a single bounded retry; pivot thereafter to avoid hanging on 404s.
              this._hlsNetworkErrorCount += 1;

              if (this._hlsNetworkErrorCount >= 2) {
                console.warn("SmartVideo: fatal NETWORK error; exceeded retries; switching to MP4/WebM fallback or poster.");
                this._fallbackFromHls();
                return;
              }

              console.warn("SmartVideo: fatal NETWORK error; retrying startLoad().");
              this._hlsInstance?.startLoad();
              return;
            }
            if (type === Hls.ErrorTypes.MEDIA_ERROR) {
              console.warn("SmartVideo: fatal MEDIA error; attempting recoverMediaError().");
              this._hlsInstance?.recoverMediaError();
              return;
            }
          } catch {
            // ignore and fall through to fallback
          }

          console.warn("SmartVideo: unrecoverable HLS fatal error; switching to MP4/WebM fallback or poster.");
           this._fallbackFromHls();
         });

        return true;
      }

      return false;
    }

    /**
     * Sets up an IntersectionObserver to automatically play or pause the video
     * when it enters or leaves the viewport.
     */
    private _initializeObserver(): void {
      this._observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              this._container.setAttribute("data-is-intersecting", "true");
              // Don't try to play if HLS has failed and we are waiting for fallback.
              if (!this._hlsFailed) {
                this._attemptPlay();
              }
            } else {
              this._container.removeAttribute("data-is-intersecting");
              this._videoElement.pause();
            }
          });
        },
        { threshold: 0.25 }, // Start playing when 25% of the video is visible.
      );

      this._observer.observe(this._videoElement);
    }
  }

  /**
   * IIFE to discover and initialize all SmartVideo components on the page.
   */
  (() => {
    const containers = document.querySelectorAll<HTMLElement>('[data-component="smart-video"]');
    if (!containers.length) {
      return;
    }

    containers.forEach(async (container) => {
      try {
        const player = new SmartVideoPlayer(container);
        await player.initialize();
      } catch (error) {
        console.error("SmartVideo: Failed to initialize player.", error);
      }
    });
  })();
</script>
