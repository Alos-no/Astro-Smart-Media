---
/**
 * @component SmartVideo
 * @description A flexible component for rendering fullscreen or container-bound background videos.
 * It handles the complexities of modern video playback, including HLS streaming with automatic
 * fallbacks to standard MP4/WebM, and robust autoplay logic that respects browser policies.
 *
 * @feature Supports HLS streaming via `hls.js` for adaptive bitrate streaming.
 * @feature Gracefully falls back to standard `<video>` sources (`.mp4`/`.webm`) if HLS is
 *   unsupported or not provided.
 * @feature Uses native HLS playback on Safari for optimal performance.
 * @feature Intelligent autoplay: uses IntersectionObserver to play/pause when in view.
 * @feature Optional play-on-hover functionality.
 * @feature Includes a poster image (`<SmartImage>`) for fast initial paint and as a
 *   fallback visual.
 * @feature Injects SEO-friendly JSON-LD `VideoObject` schema if metadata is provided.
 * @feature hlsMobileSrc: use a different HLS manifest on mobile (android/ios) via UA heuristic.
 * @feature Dual poster configurations:
 *    - Loading poster (shown eagerly): typically low quality, super fast.
 *    - Error poster (shown on playback failure): higher quality because it remains visible.
 * @feature Separate CSS classes for loading vs error poster wrapper.
 * @feature Separate error poster sizes/widths/formats/quality to avoid duplication and enable optimal UX.
 *
 * @see https://github.com/video-dev/hls.js/ for HLS client-side library.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API
 *
 * @example
 * <!-- With HLS and a fallback -->
 * <SmartVideo
 *   hlsSrc="/videos/stream/index.m3u8"
 *   src="/videos/fallback/drone"
 *   poster={posterImage}
 *   class="h-[60vh]"
 * />
 *
 * @example
 * <!-- Play on hover only -->
 * <SmartVideo
 *   src="/videos/drone"
 *   poster={posterImage}
 *   playOnHover={true}
 * />
 */

import type { ImageMetadata } from "astro";
import { DEFAULT_DURATION_ISO } from "../constants";
import SmartImage from "./SmartImage.astro";

/**
 * Defines the structured metadata for the video, used for generating
 * a JSON-LD `VideoObject` schema for SEO purposes.
 */
interface MetadataProps {
  /** A descriptive title for the video. */
  title?: string;
  /** A brief summary of the video's content. */
  description?: string;
  /** The duration of the video in ISO 8601 format (e.g., "PT1M30S"). */
  duration?: string;
  /** The original upload date of the video. */
  uploadDate?: Date;
  /** A URL to a thumbnail image. Defaults to the poster image if not provided. */
  thumbnailUrl?: string;
}

export interface Props {
  /**
   * The base path for the fallback video files (without extension). The component
   * will automatically append `.webm` and `.mp4` to create `<source>` elements.
   * This is used if `hlsSrc` is not provided, or if HLS playback fails.
   * @example "/videos/hero-fallback"
   */
  src?: string;

  /**
   * The URL to the HLS manifest file (`.m3u8`). Used for desktop if hlsMobileSrc is specified. If provided, the component will
   * attempt to use `hls.js` for adaptive streaming.
   */
  hlsSrc?: string;

  /**
   * URL to an alternate HLS `.m3u8` manifest used only on mobile (android/ios), detected via UA.
   * If not provided, falls back to `hlsSrc`.
   */
  hlsMobileSrc?: string;

  /**
   * Poster image displayed initially (loading) and/or on errors. Same URL for both states,
   * but you can configure different responsive settings between loading and error modes.
   */
  poster?: string | ImageMetadata;

  /** Root container classes. */
  class?: string;

  /**
   * Whether the video should attempt to play automatically.
   * This is ignored if `playOnHover` is `true`.
   * @default true
   */
  autoplay?: boolean;

  /**
   * Whether the video should loop continuously.
   * @default true
   */
  loop?: boolean;

  /**
   * Whether the video should be muted. Autoplay in most modern browsers
   * is only allowed for muted videos.
   * @default true
   */
  muted?: boolean;

  /**
   * Whether to display the browser's default video controls.
   * @default false
   */
  controls?: boolean;

  /**
   * The `playsinline` attribute, which is critical for preventing fullscreen
   * playback on iOS devices.
   * @default true
   */
  playsinline?: boolean;

  /**
   * How aggressively to preload the video resource.
   * Defaults to `"metadata"` to limit bandwidth while keeping first-frame fast.
   * @default "metadata"
   */
  preload?: "none" | "metadata" | "auto";

  /**
   * If `true`, the video will only play when the user hovers the mouse over it.
   * The poster image is shown when the video is paused.
   * @default false
   */
  playOnHover?: boolean;

  /**
   * When set to "on-error", the poster will NOT be rendered initially and will only
   * be injected into the DOM if the video fails to load (native error or after HLS
   * fallback also errors). Default "eager" preserves existing behavior.
   * @default "eager"
   */
  posterLoadStrategy?: "eager" | "on-error";

  /**
   * Rich metadata for SEO (schema.org `VideoObject`). If provided, a
   * `<script type="application/ld+json">` tag will be injected.
   */
  metadata?: MetadataProps;

  // --- Poster <SmartImage> Props ---

  /** Vignette radius to pass to the internal `<SmartImage>` poster (0–100). */
  imgVignetteRadius?: number;
  /** Vignette strength to pass to the internal `<SmartImage>` poster (0–1). */
  imgVignetteStrength?: number;
  /** `sizes` attribute for the poster image. */
  imgSizes?: string;
  /** `widths` attribute for the poster image. */
  imgWidths?: number[];
  /** `formats` attribute for the poster image. */
  imgFormats?: Array<"avif" | "webp" | "png" | "jpg">;
  /** `quality` attribute for the poster image. */
  imgQuality?: number;
  imgClass?: string;

  /**
   * Error poster SmartImage props (shown when video fails).
   * Defaults to the corresponding loading poster props if omitted.
   */
  errorImgSizes?: string;
  errorImgWidths?: number[];
  errorImgFormats?: Array<"avif" | "webp" | "png" | "jpg">;
  errorImgQuality?: number;
  errorImgClass?: string;

  /**
   * Visual resize strategy applied to poster and <video>. Maps to CSS object-fit.
   * @default 'cover' (or 'contain' when sizeStrategy === 'intrinsic')
   */
  fit?: "cover" | "contain" | "fill" | "none" | "scale-down";

  /**
   * Crop anchor for poster/video. Maps to CSS `object-position` (e.g. "center", "top",
   * "50% 30%", "left bottom").
   * @default 'center'
   */
  objectPosition?: string;

  /**
   * Framework-agnostic sizing behavior for the root container.
   * - "fill": always set `width: 100%` and `height: 100%` inline on the root.
   * - "none": do not set inline width/height; sizing is left entirely to the caller’s CSS.
   * - "intrinsic": let the `<video>` be in normal flow (`width:100%; height:auto`) so height is
   *   computed from its intrinsic aspect ratio. The poster matches this behavior. Useful when
   *   you do not know the media dimensions ahead of time and want automatic height.
   * @default "fill"
   */
  sizeStrategy?: "fill" | "none" | "intrinsic";

  /**
   * Optional HTML5 text tracks to attach to the <video>. Used for time-aligned metadata
   * (e.g., chapter/segment keys).
   */
  tracks?: Array<{
    kind: "metadata" | "chapters" | "subtitles" | "captions" | "descriptions";
    src: string;
    label?: string;
    srclang?: string;
    default?: boolean;
  }>;
}

// #region Extract and Process Props
// ---

const {
  src,
  hlsSrc,
  hlsMobileSrc,
  poster,
  class: className = "",
  autoplay = true,
  loop = true,
  muted = true,
  controls = false,
  playsinline = true,
  playOnHover = false,
  preload = "metadata",
  metadata,
  imgVignetteRadius,
  imgVignetteStrength,
  imgSizes,
  imgWidths,
  imgFormats,
  imgQuality,
  imgClass,
  errorImgSizes,
  errorImgWidths,
  errorImgFormats,
  errorImgQuality,
  errorImgClass,
  fit = "cover",
  objectPosition = "center",
  sizeStrategy = "fill",
  tracks = [],
  posterLoadStrategy = "eager",
} = Astro.props;

// ---
// #endregion

// #region Helper Functions
// ---

/**
 * A helper function to extract the `src` string from either a URL string
 * or an `ImageMetadata` object.
 * @param source The poster prop.
 * @returns The string URL of the image source.
 */
function getSourceString(source: string | ImageMetadata): string {
  return typeof source === "string" ? source : source.src;
}

const posterSrc = poster ? getSourceString(poster) : undefined;
const posterMode = posterLoadStrategy === "on-error" ? "on-error" : "eager";

// Extract intrinsic poster dimensions when available (local ImageMetadata),
// so the client can compute a safe aspect-ratio fallback if parent percent
// heights do not resolve (common Safari behavior with aspect-ratio ancestors).
const posterNaturalWidth =
  typeof poster === "object" && poster !== null && "width" in (poster as any)
    ? (poster as ImageMetadata).width
    : undefined;

const posterNaturalHeight =
  typeof poster === "object" && poster !== null && "height" in (poster as any)
    ? (poster as ImageMetadata).height
    : undefined;

/** Resolve effective visual strategy defaults. */
const effectiveFit = (fit ?? "cover") as "cover" | "contain" | "fill" | "none" | "scale-down";
const effectiveObjectPosition = objectPosition ?? "center";

/**
 * Compute inline style for the root container:
 * - Always cap width via max-width for safety.
 * - Inline width/height are controlled explicitly by `sizeStrategy`,
 *   making this behavior framework-agnostic and predictable.
 */
const rootStyle = [
  "position: relative;", // Ensure absolute children are anchored even without Tailwind.
  "overflow: hidden;", // Clip poster/video without relying on Tailwind.
  "border-radius: inherit;", // Ensure clipping follows parent rounded corners (Safari quirk).
  "max-width: 100%;",
  sizeStrategy === "fill" ? "width: 100%;" : "",
  // Safari can fail to resolve percentage heights when the parent’s height
  // is derived via aspect-ratio or other intrinsic sizing. Provide both
  // standard and WebKit intrinsic fallbacks, plus logical block-size.
  sizeStrategy === "fill" ? "height: 100%;" : "",
  sizeStrategy === "fill" ? "height: -webkit-fill-available;" : "",
  sizeStrategy === "fill" ? "block-size: 100%;" : "",
]
  .filter(Boolean)
  .join(" ");

/**
 * Inline styles for the `<video>` based on sizing strategy.
 * - intrinsic: use the element's intrinsic aspect ratio to compute height.
 * - others: keep absolute cover behavior for background-style usage.
 */
const videoStyle =
  sizeStrategy === "intrinsic"
    ? `display: block; position: static; width: 100%; height: auto; object-fit: ${effectiveFit}; object-position: ${effectiveObjectPosition}; border-radius: inherit; z-index: 1;`
    : `position: absolute; inset: 0; width: 100%; height: 100%; object-fit: ${effectiveFit}; object-position: ${effectiveObjectPosition}; border-radius: inherit; z-index: 1;`;

/** Poster mirrors the same visual behavior. */
const posterObjectFit = effectiveFit;

/** Build SmartImage props shared across loading and error posters. */
const basePosterImageProps = poster
  ? {
      src: poster,
      alt: metadata?.title || "Video poster",
      loading: "eager" as const,
      vignetteRadius: imgVignetteRadius,
      vignetteStrength: imgVignetteStrength,
      fit: posterObjectFit,
      position: effectiveObjectPosition,
      style: "display: block; width: 100%; height: 100%; min-width: 100%; min-height: 100%;",
    }
  : null;

/** Loading poster image props (defaults to original poster config). */
const loadingPosterImageProps = basePosterImageProps && {
  ...basePosterImageProps,
  sizes: imgSizes,
  widths: imgWidths,
  formats: imgFormats,
  quality: imgQuality,
};

/** Error poster image props: override sizes/widths/formats/quality only, default to loading props otherwise. */
const errorPosterImageProps = basePosterImageProps && {
  ...basePosterImageProps,
  sizes: errorImgSizes ?? imgSizes,
  widths: errorImgWidths ?? imgWidths,
  formats: errorImgFormats ?? imgFormats,
  quality: errorImgQuality ?? imgQuality,
};

/** Prepare initial wrapper classes. At mount we are in "loading" state when poster is eager. */
const initialPosterWrapperClass = poster && posterMode === "eager" && imgClass ? String(imgClass).trim() : undefined;

// #endregion

// #region SEO JSON-LD Schema

/**
 * Construct the `VideoObject` for JSON-LD if metadata is provided.
 * This helps search engines understand the content of the video.
 */
const videoMetadata = metadata && {
  "@context": "https://schema.org",
  "@type": "VideoObject",
  name: metadata.title || "Background Video",
  description: metadata.description || "Background video content",
  thumbnailUrl: metadata.thumbnailUrl || posterSrc,
  uploadDate: metadata.uploadDate ? metadata.uploadDate.toISOString() : new Date().toISOString(),
  duration: metadata.duration || DEFAULT_DURATION_ISO,
};

// ---
// #endregion
---

<!--
  The root container passes all necessary configuration to the client-side script
  via `data-*` attributes. This is a standard Astro pattern for hydrating components
  with dynamic data without needing `define:vars`.
-->
<div
  data-component="smart-video"
  data-hls-src={hlsSrc ?? ""}
  data-hls-mobile-src={hlsMobileSrc ?? ""}
  data-src-fallback={src ?? ""}
  data-autoplay={autoplay ? "true" : "false"}
  data-play-on-hover={playOnHover ? "true" : "false"}
  class={`${className}`}
  style={rootStyle}
  data-poster-mode={poster ? posterMode : undefined}
  data-poster-loading-class={imgClass ? String(imgClass) : undefined}
  data-poster-error-class={errorImgClass ? String(errorImgClass) : undefined}
  data-poster-width={posterNaturalWidth !== undefined ? String(posterNaturalWidth) : undefined}
  data-poster-height={posterNaturalHeight !== undefined ? String(posterNaturalHeight) : undefined}
>
  <!-- Inject the JSON-LD schema if it was created. -->
  {videoMetadata && <script type="application/ld+json" set:html={JSON.stringify(videoMetadata)} />}

  <!-- 
    The poster element. It uses <SmartImage> for performance. It's positioned
    absolutely to cover the video element until playback begins.
  -->
  {
    /* Poster wrapper: always present when poster is set.
       - In eager mode: render low-quality loading poster immediately (fast paint).
       - In on-error mode: initially empty; inject only on failure. */
  }
  {
    poster && (
      <div
        data-poster
        class={initialPosterWrapperClass}
        style="
          position: absolute;
          inset: 0;
          z-index: 2; /* Ensure poster paints above <video> */
          pointer-events: none; /* Overlay never blocks hover/clicks on container */
          transition: opacity 150ms ease-out;
          overflow: hidden; /* Clip to container so cropping matches SmartImage behavior */
          border-radius: inherit; /* Ensure poster respects rounded corners inside Safari */
        "
      >
        {posterMode === "eager" && loadingPosterImageProps && <SmartImage {...loadingPosterImageProps} />}
      </div>
    )
  }

  {
    /* Error poster (higher quality) is always available as a template so we can "upgrade" the poster
       on failure whether we started in eager or on-error mode. This centralizes the SmartImage markup
       to avoid duplication and ensures the same image URL is used with different responsive params. */
  }
  {
    poster && errorPosterImageProps && (
      <template data-error-poster-template>
        <SmartImage {...errorPosterImageProps} />
      </template>
    )
  }

  <!-- 
    The core HTML5 <video> element. It starts empty and is populated with <source>
    elements by the client-side script.
  -->
  <video
    data-video
    preload={preload}
    loop={loop ? true : undefined}
    muted={muted ? true : undefined}
    controls={controls ? true : undefined}
    playsinline={playsinline ? true : undefined}
    webkit-playsinline={playsinline ? true : undefined}
    crossorigin="anonymous"
    style={videoStyle}
  >
    {
      Array.isArray(tracks) &&
        tracks.map((trk) => (
          <track
            kind={trk.kind}
            src={trk.src}
            label={trk.label}
            srclang={trk.srclang}
            default={trk.default ? true : undefined}
          />
        ))
    }
    <!-- Fallback message for browsers that don't support the <video> tag. -->
    <p>Your browser doesn't support HTML5 video.</p>
  </video>
</div>

<!-- 
  Client-Side Logic:
  This script is processed by Astro as a module. It will only be included once per page,
  even if multiple <SmartVideo> components are present. It queries for all component
  instances and initializes them based on their unique `data-*` attributes.
-->
<script>
  // Import the HLS.js library for adaptive streaming.
  import type Hls from "hls.js";

  /**
   * Platform classification using the provided UA heuristic.
   * Unknown platform is considered desktop.
   */
  function getPlatformName(): "android" | "ios" | "windows" | "osx" | "linux" | "cros" | null {
    const ua = typeof navigator !== "undefined" ? navigator.userAgent : "";
    return /android/i.test(ua)
      ? "android"
      : /ip(?:[ao]d|hone)/i.test(ua)
        ? "ios"
        : /windows/i.test(ua)
          ? "windows"
          : /mac os/i.test(ua)
            ? "osx"
            : /linux/i.test(ua)
              ? "linux"
              : /cros/i.test(ua)
                ? "cros"
                : null;
  }

  function isMobilePlatform(): boolean {
    const p = getPlatformName();
    return p === "android" || p === "ios";
  }

  /**
   * Manages the state and interactions of a single SmartVideo component instance.
   * This class encapsulates all client-side logic, including HLS playback,
   * fallbacks, and IntersectionObserver-based autoplay.
   */
  class SmartVideoPlayer {
    private _container: HTMLElement;
    private _videoElement: HTMLVideoElement;
    private _posterElement: HTMLElement | null;
    private _hlsInstance: Hls | null = null;
    private _observer: IntersectionObserver | null = null;

    // HLS readiness and retry bookkeeping (hls.js path only).
    private _hlsReady: boolean = false; // Set true on MANIFEST_PARSED
    private _hlsStartupTimer: number | null = null; // Watchdog to avoid hanging on startup
    private _hlsNetworkErrorCount: number = 0; // Bounded retries for fatal NETWORK errors

    // Configuration flags read from data attributes
    private _hlsSrc: string | null;
    private _hlsMobileSrc: string | null;
    private _effectiveHlsSrc: string | null;
    private _fallbackSrc: string | null;
    private _playOnHover: boolean;
    private _shouldAutoplay: boolean;
    private _hlsFailed = false;

    // Poster lazy-injection state
    private _posterMode: "eager" | "on-error";
    private _errorPosterTemplate: HTMLTemplateElement | null;
    private _posterInjected = false;

    // Hover bookkeeping:
    //  - _hoverTarget is the element that owns hover intent (wrapper if present, otherwise the component container).
    //  - _isHovering reflects whether the pointer is currently over _hoverTarget.
    private _hoverTarget: HTMLElement | null = null;
    private _isHovering: boolean = false;

    // Poster class handling (loading vs error)
    private _posterLoadingClassName: string = "";
    private _posterErrorClassName: string = "";

    // Layout fallback bookkeeping (for old WebKit w/o CSS aspect-ratio).
    private _layoutFallbackApplied: boolean = false;
    private _onResizeBound: () => void = () => this._applyLayoutFallbackIfCollapsed();

    /**
     * Initializes the player instance.
     * @param {HTMLElement} container - The root `div` element of the component.
     */
    constructor(container: HTMLElement) {
      this._container = container;
      const videoEl = container.querySelector<HTMLVideoElement>("[data-video]");
      const posterEl = container.querySelector<HTMLElement>("[data-poster]");

      if (!videoEl) {
        throw new Error("SmartVideoPlayer: A [data-video] element is required.");
      }

      this._videoElement = videoEl;
      this._posterElement = posterEl;

      // Read configuration from the container's data attributes.
      this._hlsSrc = container.dataset.hlsSrc || null;
      this._hlsMobileSrc = container.dataset.hlsMobileSrc || null;
      this._fallbackSrc = container.dataset.srcFallback || null;
      this._playOnHover = container.dataset.playOnHover === "true";
      this._shouldAutoplay = !this._playOnHover && container.dataset.autoplay === "true";
      this._posterMode = (container.dataset.posterMode as "eager" | "on-error") || "eager";
      this._errorPosterTemplate =
        container.querySelector<HTMLTemplateElement>("[data-error-poster-template]") ||
        container.querySelector<HTMLTemplateElement>("[data-poster-template]") ||
        null;

      this._posterLoadingClassName = container.dataset.posterLoadingClass || "";
      this._posterErrorClassName = container.dataset.posterErrorClass || "";

      // Compute effective HLS source based on UA heuristic (unknown => desktop).
      const mobile = isMobilePlatform();
      this._effectiveHlsSrc = mobile && this._hlsMobileSrc ? this._hlsMobileSrc : this._hlsSrc;

      // Expose selected source for diagnostics.
      if (this._effectiveHlsSrc) {
        this._container.setAttribute("data-hls-selected", mobile ? "mobile" : "desktop");
      }

      if (this._shouldAutoplay) {
        this._videoElement.setAttribute("autoplay", "");
      }

      // Mark initial visibility synchronously to avoid IO delay
      const r = this._container.getBoundingClientRect();

      if (r.top < window.innerHeight && r.bottom > 0 && r.left < window.innerWidth && r.right > 0) {
        this._container.setAttribute("data-is-intersecting", "true");
      }

      // Resolve the element users actually hover: prefer the wrapper parent when present.
      this._hoverTarget =
        this._container.parentElement instanceof HTMLElement ? this._container.parentElement : this._container;

      // Apply initial poster class for eager mode
      if (this._posterElement && this._posterMode === "eager") {
        this._applyPosterClassForState("loading");
      }

      // Finalize construction with a robust layout fallback:
      // If Safari (or any engine) collapses percent heights and our container ends
      // up with ~0px height, switch to a cross-browser ratio box that does not rely
      // on CSS aspect-ratio (padding-bottom trick).
      this._applyLayoutFallbackIfCollapsed();

      // Re-check on the next frame (in case layout wasn’t final yet) and on viewport changes.
      // If height becomes available later, we will revert the fallback to fill the container.
      requestAnimationFrame(() => this._applyLayoutFallbackIfCollapsed());
      window.addEventListener("resize", this._onResizeBound, { passive: true });
      window.addEventListener("orientationchange", this._onResizeBound);
    }

    /**
     * Sets up event listeners and initializes the appropriate video source
     * (HLS or standard fallback).
     */
    public async initialize(): Promise<void> {
      this._setupEventListeners();

      const hlsInitialized = await this._initializeHLS();
      if (!hlsInitialized) {
        this._appendFallbackSources();
      }

      // Also attempt autoplay once the browser reports it can play.
      // This covers both HLS and non-HLS (fallback) paths.
      this._videoElement.addEventListener("canplay", () => this._maybeAutoplayOnReady(), { once: true });

      // Autoplay logic is only enabled if hover-to-play is not active.
      if (this._shouldAutoplay) {
        this._initializeObserver();
      }
    }

    private _applyPosterClassForState(state: "loading" | "error"): void {
      if (!this._posterElement) {
        return;
      }

      const loadingClasses = (this._posterLoadingClassName || "").split(/\s+/).filter(Boolean);
      const errorClasses = (this._posterErrorClassName || "").split(/\s+/).filter(Boolean);

      // Remove both sets to avoid stacking.
      if (loadingClasses.length) {
        this._posterElement.classList.remove(...loadingClasses);
      }
      if (errorClasses.length) {
        this._posterElement.classList.remove(...errorClasses);
      }

      const add = state === "loading" ? loadingClasses : errorClasses;

      if (add.length) {
        this._posterElement.classList.add(...add);
      }
    }

    /**
     * Attempt playback only when the media is ready. If we're in hover mode,
     * we additionally require that the pointer is still over the hover target
     * at the instant we decide to start playback.
     */
    private _playWhenReady(): void {
      // If this path was triggered by hover, ensure hover intent is still active.
      if (this._playOnHover && (!this._hoverTarget || !this._isHovering)) {
        return;
      }

      // HAVE_CURRENT_DATA (2) is sufficient to begin playback.
      if (this._videoElement.readyState >= 2) {
        if (!this._playOnHover || this._isHovering) {
          this._attemptPlay();
        }
        return;
      }

      const onReady = (): void => {
        this._videoElement.removeEventListener("canplay", onReady);

        // Guard again: if the user left before readiness, do nothing.
        if (this._playOnHover && (!this._hoverTarget || !this._isHovering)) {
          return;
        }

        this._attemptPlay();
      };

      this._videoElement.addEventListener("canplay", onReady, { once: true });
    }

    /**
     * Attempt autoplay if we're intersecting and autoplay is enabled.
     * Called from readiness signals (HLS MANIFEST_PARSED, media 'canplay').
     */
    private _maybeAutoplayOnReady(): void {
      if (!this._shouldAutoplay) {
        return;
      }

      const alreadyFlagged = this._container.getAttribute("data-is-intersecting") === "true";
      const rect = this._container.getBoundingClientRect();
      const visibleNow =
        rect.top < window.innerHeight && rect.bottom > 0 && rect.left < window.innerWidth && rect.right > 0;

      if (alreadyFlagged || visibleNow) {
        this._attemptPlay();
      }
    }

    /**
     * Attempts to play the video, handling potential browser errors for blocked autoplay.
     * It retries with the video muted if the initial attempt fails.
     */
    private _attemptPlay(): void {
      const playPromise = this._videoElement.play();
      if (playPromise) {
        playPromise.catch((err) => {
          console.info("SmartVideo: Autoplay was blocked. Muting and retrying.", err);
          this._videoElement.muted = true;
          this._videoElement.play().catch((err2) => {
            console.info("SmartVideo: Muted autoplay also failed.", err2);
          });
        });
      }
    }

    /**
     * Sets up all necessary DOM event listeners for the component.
     */
    private _setupEventListeners(): void {
      // Fade out the poster when the video starts playing.
      this._videoElement.addEventListener("playing", () => {
        if (this._posterElement) {
          this._posterElement.style.opacity = "0";
        }
      });

      // Show the poster again when paused if hover-to-play is enabled.
      this._videoElement.addEventListener("pause", () => {
        if (this._posterElement && this._playOnHover) {
          this._posterElement.style.opacity = "1";
          this._applyPosterClassForState("loading");
        }
      });

      // If the video encounters an unrecoverable error (native path or after fallback),
      // inject the poster only when posterMode === "on-error".
      this._videoElement.addEventListener("error", () => {
        this._handleVideoError();
      });

      // Handle hover-based playback.
      if (this._playOnHover) {
        // Attach to the element users actually hover (wrapper if present).
        const target = this._hoverTarget ?? this._container;

        const onEnter = (): void => {
          this._isHovering = true;
          this._playWhenReady();
        };

        const onLeave = (): void => {
          this._isHovering = false;
          this._videoElement.pause();
        };

        target.addEventListener("mouseenter", onEnter);
        target.addEventListener("mouseleave", onLeave);
      }
    }

    /**
     * When the root container ends up with zero (or near-zero) height due to
     * percentage height resolution quirks (notably on Safari when a parent uses
     * aspect-ratio), apply a safe, intrinsic fallback:
     *   - Drop the inline 100% height.
     *   - Set aspect-ratio from the poster’s intrinsic size if known, otherwise 16/9.
     * This ensures the container participates in layout and that absolutely
     * positioned poster/video children have a box to fill.
     */
    private _applyLayoutFallbackIfCollapsed(): void {
      try {
        const h = this._container.clientHeight;

        // If we now have a usable height, and we previously applied the fallback,
        // revert to the default fill sizing so the hero fills its 65vh container.
        if (h > 1) {
          if (this._layoutFallbackApplied) {
            // Remove padding box sizing and restore 100% fill sizing.
            this._container.style.removeProperty("padding-bottom");
            this._container.style.height = "100%";
            this._container.style.setProperty("block-size", "100%");
            // Ensure any aspect-ratio leftovers are cleared.
            (this._container.style as any).aspectRatio = "";
            this._container.removeAttribute("data-size-fallback");
            this._layoutFallbackApplied = false;
          }

          return;
        }

        // Prefer intrinsic poster dimensions when provided by the server.
        const pw = parseInt(this._container.dataset.posterWidth || "", 10);
        const ph = parseInt(this._container.dataset.posterHeight || "", 10);

        const ratio = pw > 0 && ph > 0 ? pw / ph : 16 / 9;

        // Override the inline height from sizeStrategy="fill" and switch to AR.
        // Use a padding-bottom ratio box so old Safari (no CSS aspect-ratio) behaves.
        this._container.style.removeProperty("block-size");
        this._container.style.height = "0px";
        this._container.style.paddingBottom = `${(1 / ratio) * 100}%`;
        this._container.setAttribute("data-size-fallback", "padding");
        this._layoutFallbackApplied = true;
      } catch {
        // Best-effort only; do not throw.
      }
    }

    /**
     * Inject or upgrade the poster to the higher-quality error version.
     * - In "on-error" mode: the wrapper is initially empty; we inject the template.
     * - In "eager" mode: replace the low-quality loading poster with the error version.
     */
    private _ensureErrorPoster(): void {
      if (!this._posterElement || !this._errorPosterTemplate) {
        return;
      }

      // Replace current content with error poster (idempotent on second calls).
      this._posterElement.innerHTML = "";
      const fragment = this._errorPosterTemplate.content.cloneNode(true) as DocumentFragment;
      this._posterElement.appendChild(fragment);

      this._posterInjected = true;
      this._posterElement.style.opacity = "1";
      this._applyPosterClassForState("error");
    }

    /**
     * Handle native video errors by showing the poster when configured for on-error.
     */
    private _handleVideoError(): void {
      this._ensureErrorPoster();
    }

    /**
     * Appends standard `<source>` elements for WebM and MP4 formats.
     * This is used as a fallback if HLS is not supported or fails.
     */
    private _appendFallbackSources(): void {
      if (!this._fallbackSrc) return;

      // Clear any existing sources before adding new ones.
      this._videoElement.innerHTML = "";

      const sourceWebm = document.createElement("source");
      sourceWebm.src = `${this._fallbackSrc}.webm`;
      sourceWebm.type = "video/webm";
      this._videoElement.appendChild(sourceWebm);

      const sourceMp4 = document.createElement("source");
      sourceMp4.src = `${this._fallbackSrc}.mp4`;
      sourceMp4.type = "video/mp4";
      this._videoElement.appendChild(sourceMp4);

      // We need to tell the video element to load the new sources.
      this._videoElement.load();
    }

    /**
     * Shared helper to pivot from HLS to static <source> fallbacks.
     * Ensures we do this exactly once and then re-attempt playback if we should be playing.
     */
    private _fallbackFromHls(): void {
      // Mark that we should not attempt HLS again during this lifecycle.
      this._hlsFailed = true;

      // Stop any startup watchdog.
      if (this._hlsStartupTimer !== null) {
        clearTimeout(this._hlsStartupTimer);
        this._hlsStartupTimer = null;
      }

      // Tear down any active hls.js instance (no-op if null).
      this._hlsInstance?.destroy();

      // Surface playback path for diagnostics/inspection UIs.
      this._container.setAttribute("data-playback-mode", "fallback");

      // Clear any native src and switch to appended sources.
      this._videoElement.removeAttribute("src");
      this._appendFallbackSources();

      // If no MP4/WebM fallback was provided, ensure the poster is shown.
      if (!this._fallbackSrc) {
        console.warn("SmartVideo: No MP4/WebM fallback provided; showing error poster due to HLS failure.");
        this._ensureErrorPoster();
        return;
      }

      // If we are visible and expected to autoplay, try to play now.
      if (this._container.getAttribute("data-is-intersecting") === "true" && this._videoElement.paused) {
        this._attemptPlay();
      }
    }

    /**
     * Initializes HLS playback if an HLS source is provided and the browser supports it.
     * Uses native HLS when available; otherwise dynamically imports hls.js.
     * @returns {Promise<boolean>} `true` if HLS was successfully initialized, `false` otherwise.
     */
    private async _initializeHLS(): Promise<boolean> {
      if (!this._effectiveHlsSrc) return false;

      // Safari on macOS and iOS has native HLS support.
      if (this._videoElement.canPlayType("application/vnd.apple.mpegurl")) {
        // Native path: set the src and guard with a watchdog so we don't hang forever in environments
        // where canPlayType() is overly optimistic or codecs are unavailable (e.g., CI WebKit builds).
        const v = this._videoElement;

        let settled = false; // tracks whether ready or error fired
        const settle = (): void => {
          if (settled) return;
          settled = true;
          v.removeEventListener("loadedmetadata", onReady);
          v.removeEventListener("canplay", onReady);
          v.removeEventListener("error", onError);
        };

        const onReady = (): void => {
          settle();
          // Expose that native HLS is active.
          this._container.setAttribute("data-playback-mode", "native-hls");
          // Defer to normal ready → maybe autoplay flow.
          this._maybeAutoplayOnReady();
        };

        const onError = (): void => {
          settle();
          console.warn("SmartVideo: Native HLS failed to become ready. Falling back to <source>.");
          this._ensureErrorPoster();
          this._fallbackFromHls();
        };

        v.addEventListener("loadedmetadata", onReady, { once: true });
        v.addEventListener("canplay", onReady, { once: true });
        v.addEventListener("error", onError, { once: true });

        // Assign after listeners in case the event fires immediately.
        v.src = this._effectiveHlsSrc;

        // Watchdog timeout as a last resort if neither ready nor error fires promptly.
        window.setTimeout(() => {
          if (!settled) onError();
        }, 4000);

        return true;
      }

      // Dynamically import hls.js only when needed to avoid blocking page load.
      let HlsMod: typeof Hls;

      try {
        HlsMod = await import("hls.js");
      } catch (e) {
        console.warn("SmartVideo: Failed to load hls.js module; using fallback sources.", e);
        return false;
      }

      const HlsCtor = HlsMod?.default;

      // Use hls.js for other browsers that support Media Source Extensions.
      if (HlsCtor && HlsCtor.isSupported()) {
        // Conservative, startup-focused defaults. See hls.js config docs.
        this._hlsInstance = new HlsCtor({
          startLevel: 0, // ensure smallest rendition first for fastest first frame
          startFragPrefetch: true, // fetch next frag while playing current
          autoStartLoad: true,
          capLevelToPlayerSize: true,
          lowBufferWatchdogPeriod: 0.5,
          highBufferWatchdogPeriod: 2,
          nudgeMaxRetry: 3,
        });

        this._hlsInstance.loadSource(this._effectiveHlsSrc);
        this._hlsInstance.attachMedia(this._videoElement);

        // Startup watchdog: if MANIFEST_PARSED never arrives, pivot to fallback/poster.
        this._hlsStartupTimer = window.setTimeout(() => {
          if (!this._hlsReady && !this._hlsFailed) {
            console.warn("SmartVideo: HLS startup timed out; switching to MP4/WebM fallback or poster.");
            this._fallbackFromHls();
          }
        }, 4000);

        // When the manifest is parsed, HLS is ready to start playback.
        // If we're intersecting and autoplay is desired, try again now.
        this._hlsInstance.on(HlsCtor.Events.MANIFEST_PARSED, () => {
          this._container.setAttribute("data-playback-mode", "hls.js");
          this._hlsReady = true;

          if (this._hlsStartupTimer !== null) {
            clearTimeout(this._hlsStartupTimer);
            this._hlsStartupTimer = null;
          }

          this._maybeAutoplayOnReady();
        });

        this._hlsInstance.on(HlsCtor.Events.ERROR, (event, data) => {
          const details = (data && (data as any).details) || "unknown";
          const fatal = !!(data && (data as any).fatal);

          // Downgrade noisy, non-fatal stall logs.
          if (!fatal) {
            if (details === "bufferStalledError" || details === "bufferNudgeOnStall") {
              console.debug("SmartVideo: non-fatal HLS stall:", details);
            } else {
              console.warn("SmartVideo: non-fatal HLS error:", details);
            }
            return;
          }

          // Immediately show error poster for fatal HLS errors and pivot to fallback.
          this._ensureErrorPoster();

          // Attempt targeted recovery before falling back.
          try {
            const type = (data as any).type;
            if (type === HlsCtor.ErrorTypes.NETWORK_ERROR) {
              // Allow a single bounded retry; pivot thereafter to avoid hanging on 404s.
              this._hlsNetworkErrorCount += 1;

              if (this._hlsNetworkErrorCount >= 2) {
                console.warn("SmartVideo: fatal NETWORK error; exceeded retries; switching to fallback/poster.");
                this._fallbackFromHls();
                return;
              }

              console.warn("SmartVideo: fatal NETWORK error; retrying startLoad().");
              this._hlsInstance?.startLoad();
              return;
            }

            if (type === HlsCtor.ErrorTypes.MEDIA_ERROR) {
              console.warn("SmartVideo: fatal MEDIA error; attempting recoverMediaError().");
              this._hlsInstance?.recoverMediaError();
              return;
            }
          } catch {
            // ignore and fall through to fallback
          }

          console.warn("SmartVideo: unrecoverable HLS fatal error; switching to fallback/poster.");
          this._fallbackFromHls();
        });

        return true;
      }

      return false;
    }

    /**
     * Sets up an IntersectionObserver to automatically play or pause the video
     * when it enters or leaves the viewport.
     */
    private _initializeObserver(): void {
      this._observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              this._container.setAttribute("data-is-intersecting", "true");
              // Don't try to play if HLS has failed and we are waiting for fallback.
              if (!this._hlsFailed) {
                this._attemptPlay();
              }
            } else {
              this._container.removeAttribute("data-is-intersecting");
              this._videoElement.pause();
            }
          });
        },
        { threshold: 0.25 }, // Start playing when 25% of the video is visible.
      );

      this._observer.observe(this._videoElement);
    }
  }

  /**
   * IIFE to discover and initialize all SmartVideo components on the page.
   */
  (() => {
    const containers = document.querySelectorAll<HTMLElement>('[data-component="smart-video"]');
    if (!containers.length) {
      return;
    }

    containers.forEach(async (container) => {
      try {
        const player = new SmartVideoPlayer(container);
        await player.initialize();
      } catch (error) {
        console.error("SmartVideo: Failed to initialize player.", error);
      }
    });
  })();
</script>
